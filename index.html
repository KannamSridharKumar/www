<!DOCTYPE html>
<html>

<head>
    <title>Ultraceuticals AI Landscape</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 10px;
            background-color: #121212;
            color: #e0e0e0;
            overflow-y: auto;
        }

        h1 {
            text-align: center;
            color: #ffffff;
            margin-bottom: 15px;
            font-weight: 200;
            letter-spacing: 1px;
            font-size: 1.5em;
        }

        .container {
            display: flex;
            justify-content: space-between;
            position: relative;
            max-width: 1200px;
            margin: 0 auto;
        }

        .column {
            width: 30%;
            padding: 8px;
            background-color: #1e1e1e;
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            border: 1px solid #333;
        }

        .column h2 {
            text-align: center;
            margin-bottom: 10px;
            color: #ffffff;
            font-weight: 400;
            border-bottom: 1px solid #333;
            padding-bottom: 6px;
            font-size: 1em;
        }

        .cell {
            padding: 2px 4px;
            margin: 3px 0;
            border-radius: 3px;
            background-color: #2a2a2a;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 2px solid transparent;
            font-size: 0.8em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .cell:hover {
            background-color: #3a3a3a;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #tech-column .cell {
            border-left-color: #ff6b6b;
        }

        #usecase-column .cell {
            border-left-color: #4ecdc4;
        }

        #dataset-column .cell {
            border-left-color: #ffd166;
        }

        .cell.highlighted {
            background-color: #3a3a3a;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        #tech-column .cell.highlighted {
            background-color: rgba(255, 107, 107, 0.3);
        }

        #usecase-column .cell.highlighted {
            background-color: rgba(78, 205, 196, 0.3);
        }

        #dataset-column .cell.highlighted {
            background-color: rgba(255, 209, 102, 0.3);
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        /* Subgroup styles */
        .subgroup {
            margin: 8px 0;
            padding: 4px;
            border-radius: 4px;
        }

        .subgroup-title {
            font-size: 0.75em;
            font-weight: 600;
            margin-bottom: 4px;
            padding-bottom: 2px;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.2);
        }

        /* Higher-level grouping container */
        .grouping-container {
            margin-bottom: 20px;
            padding: 10px;
            background-color: #1e1e1e;
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            border: 1px solid #333;
        }

        .grouping-title {
            text-align: center;
            margin-bottom: 10px;
            color: #ffffff;
            font-weight: 400;
            border-bottom: 1px solid #333;
            padding-bottom: 6px;
            font-size: 1em;
        }

        .grouping-row {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 8px;
        }

        .grouping-tag {
            padding: 4px 8px;
            background-color: #333;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8em;
            border-left: 2px solid #4ecdc4;
        }

        .grouping-tag:hover {
            background-color: #444;
            transform: translateY(-1px);
        }

        .grouping-tag.active {
            background-color: rgba(78, 205, 196, 0.4);
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.3);
        }

        /* Subgroup color classes */
        .ai-tech {
            background-color: rgba(255, 107, 107, 0.15);
            border: 1px solid rgba(255, 107, 107, 0.3);
        }

        .data-storage {
            background-color: rgba(78, 205, 196, 0.15);
            border: 1px solid rgba(78, 205, 196, 0.3);
        }

        .automation {
            background-color: rgba(255, 209, 102, 0.15);
            border: 1px solid rgba(255, 209, 102, 0.3);
        }

        .ecommerce-platform {
            background-color: rgba(58, 134, 255, 0.15);
            border: 1px solid rgba(58, 134, 255, 0.3);
        }

        .cloud-infra {
            background-color: rgba(114, 9, 183, 0.15);
            border: 1px solid rgba(114, 9, 183, 0.3);
        }

        .inventory-management {
            background-color: rgba(6, 214, 160, 0.15);
            border: 1px solid rgba(6, 214, 160, 0.3);
        }

        .marketing-content {
            background-color: rgba(247, 37, 133, 0.15);
            border: 1px solid rgba(247, 37, 133, 0.3);
        }

        .sales-revenue {
            background-color: rgba(138, 201, 38, 0.15);
            border: 1px solid rgba(138, 201, 38, 0.3);
        }

        .customer-experience {
            background-color: rgba(255, 107, 107, 0.15);
            border: 1px solid rgba(255, 107, 107, 0.3);
        }

        .operations {
            background-color: rgba(58, 134, 255, 0.15);
            border: 1px solid rgba(58, 134, 255, 0.3);
        }

        .b2b-automation {
            background-color: rgba(114, 9, 183, 0.15);
            border: 1px solid rgba(114, 9, 183, 0.3);
        }

        .inventory-logistics {
            background-color: rgba(6, 214, 160, 0.15);
            border: 1px solid rgba(6, 214, 160, 0.3);
        }

        .historical-data {
            background-color: rgba(247, 37, 133, 0.15);
            border: 1px solid rgba(247, 37, 133, 0.3);
        }

        .customer-data {
            background-color: rgba(138, 201, 38, 0.15);
            border: 1px solid rgba(138, 201, 38, 0.3);
        }

        .marketing-data {
            background-color: rgba(255, 107, 107, 0.15);
            border: 1px solid rgba(255, 107, 107, 0.3);
        }

        .product-inventory {
            background-color: rgba(58, 134, 255, 0.15);
            border: 1px solid rgba(58, 134, 255, 0.3);
        }

        .transactional-data {
            background-color: rgba(114, 9, 183, 0.15);
            border: 1px solid rgba(114, 9, 183, 0.3);
        }

        /* Tooltip for long text */
        .cell:hover::after {
            content: attr(data-value);
            position: absolute;
            background: #333;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            z-index: 1;
            font-size: 0.75em;
            max-width: 200px;
            word-wrap: break-word;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>

<body>
    <h1>Ultraceuticals AI Landscape</h1>

    <!-- Higher-level grouping container -->
    <div class="grouping-container">
        <div class="grouping-title">Capability-Usecase Mapping</div>

        <!-- Top-level grouping row -->
        <div class="grouping-row" id="top-level-groups">
            <!-- Will be populated dynamically -->
        </div>

        <!-- Second-level grouping row -->
        <div class="grouping-row" id="second-level-groups">
            <!-- Will be populated dynamically -->
        </div>
    </div>

    <div class="container">
        <canvas id="canvas"></canvas>
        <div class="column" id="tech-column">
            <h2>Technology</h2>
            <!-- Subgroups will be added here dynamically -->
        </div>

        <div class="column" id="usecase-column">
            <h2>Usecase</h2>
            <!-- Subgroups will be added here dynamically -->
        </div>

        <div class="column" id="dataset-column">
            <h2>Dataset</h2>
            <!-- Subgroups will be added here dynamically -->
        </div>
    </div>

    <script>
        const data = [
            ["Generative AI", "AI-Enabled Content Creation", "Customer Interests"],
            ["Recommendation Engine", "Personalized Product Recommendation", "User Behavior"],
            ["AI Chatbots", "Personalized Advice & Consultation", "Customer Preferences"],
            ["CDP", "Integrated data layer", "Customer Interactions"],
            ["AI/ML Models", "Forecasting sales model", "Historical Sales Data"],
            ["Netstock", "Store inventory levels", "Inventory Levels"],
            ["Cloud Platform", "Trigger events", "Customer Journey"],
            ["OCR & NLP Models", "Extract from invoices", "Invoice Documents"]
        ];

        // Higher-level grouping
        const topLevelGrouping = {
            "DTC": ["Marketing & Content", "Customer Experience & Engagement"],
            "BTB": ["Operational Efficiency", "B2B Process Automation"],
            "Mktg & SCM": ["Sales & Revenue Optimization", "Inventory & Logistics"]
        };

        const subgroups = {
            tech: {
                "AI Technologies": {
                    items: ["Generative AI", "AI Chatbots", "AI/ML Models"],
                    class: "ai-tech"
                },
                "Data Storage & Processing": {
                    items: ["CDP", "OCR & NLP Models"],
                    class: "data-storage"
                },
                "Cloud & Infrastructure": {
                    items: ["Cloud Platform"],
                    class: "cloud-infra"
                },
                "Inventory & Order Management": {
                    items: ["Netstock"],
                    class: "inventory-management"
                },
                "Other Technologies": {
                    items: ["Recommendation Engine"],
                    class: "other-tech"
                }
            },

            usecase: {
                "Branding, Promotions, Awareness​": {
                    items: ["AI-Enabled Content Creation"],
                    class: "marketing-content"
                },
                "Product Discovery​": {
                    items: ["Personalized Product Recommendation", "Forecasting sales model"],
                    class: "sales-revenue"
                },
                "Product Selection​": {
                    items: ["Personalized Advice & Consultation"],
                    class: "customer-experience"
                },
                "Check Out & Payment​​": {
                    items: ["Integrated data layer", "Trigger events"],
                    class: "operations"
                },
                "Check Out & Payment​": {
                    items: ["Extract from invoices"],
                    class: "b2b-automation"
                },
                "Post-Purchase Customer Care & Reporting​": {
                    items: ["Store inventory levels"],
                    class: "inventory-logistics"
                }
            },

            dataset: {
                "Historical Data": {
                    items: ["Historical Sales Data"],
                    class: "historical-data"
                },
                "Customer & Behavioral Data": {
                    items: ["Customer Interests", "User Behavior", "Customer Preferences", "Customer Interactions", "Customer Journey"],
                    class: "customer-data"
                },
                "Product & Inventory Data": {
                    items: ["Inventory Levels"],
                    class: "product-inventory"
                },
                "Operational & Transactional Data": {
                    items: ["Invoice Documents"],
                    class: "transactional-data"
                }
            }
        };

        // Store connections between cells
        const connections = [];

        // Store cell elements by their content
        const cellMap = {
            tech: {},
            usecase: {},
            dataset: {}
        };

        // Map to track which subgroups belong to which top-level group
        const subgroupToTopLevelMap = {};

        // Color palette for connections
        const colors = [
            '#ff6b6b', // Red
            '#4ecdc4', // Teal
            '#ffd166', // Yellow
            '#06d6a0', // Green
            '#118ab2', // Blue
            '#7209b7', // Purple
            '#f72585', // Pink
            '#3a86ff', // Royal Blue
            '#8ac926', // Lime
            '#ffbe0b'  // Orange
        ];

        // Create the hierarchical grouping UI
        function createGroupingUI() {
            const topLevelContainer = document.getElementById('top-level-groups');
            const secondLevelContainer = document.getElementById('second-level-groups');

            // Create top-level grouping tags
            for (const [group, subgroupList] of Object.entries(topLevelGrouping)) {
                const groupTag = document.createElement('div');
                groupTag.className = 'grouping-tag';
                groupTag.textContent = group;
                groupTag.dataset.group = group;
                topLevelContainer.appendChild(groupTag);

                // Map each subgroup to its parent group
                subgroupList.forEach(subgroup => {
                    subgroupToTopLevelMap[subgroup] = group;
                });

                // Add click event for top-level grouping
                groupTag.addEventListener('click', function () {
                    // Toggle active state
                    document.querySelectorAll('#top-level-groups .grouping-tag').forEach(tag => {
                        tag.classList.remove('active');
                    });
                    this.classList.add('active');

                    // Highlight relevant second-level groups
                    highlightSecondLevelGroups(group);

                    // Find all usecases in this group and highlight connections
                    const groupUsecases = [];
                    subgroupList.forEach(subgroup => {
                        if (subgroups.usecase[subgroup]) {
                            subgroups.usecase[subgroup].items.forEach(item => {
                                groupUsecases.push(item);
                            });
                        }
                    });

                    // Highlight all connections with these usecases
                    highlightGroupConnections(groupUsecases);
                });
            }

            // Create second-level grouping tags (current usecase categories)
            for (const [group, groupInfo] of Object.entries(subgroups.usecase)) {
                const groupTag = document.createElement('div');
                groupTag.className = 'grouping-tag';
                groupTag.textContent = group;
                groupTag.dataset.group = group;
                secondLevelContainer.appendChild(groupTag);

                // Add click event for second-level grouping
                groupTag.addEventListener('click', function () {
                    // Toggle active state for second level
                    document.querySelectorAll('#second-level-groups .grouping-tag').forEach(tag => {
                        tag.classList.remove('active');
                    });
                    this.classList.add('active');

                    // Clear top-level selections
                    document.querySelectorAll('#top-level-groups .grouping-tag').forEach(tag => {
                        tag.classList.remove('active');
                    });

                    // Find all usecases in this group and highlight connections
                    const groupUsecases = subgroups.usecase[group].items;
                    highlightGroupConnections(groupUsecases);
                });
            }
        }

        // Highlight second-level groups that belong to a top-level group
        function highlightSecondLevelGroups(topLevelGroup) {
            document.querySelectorAll('#second-level-groups .grouping-tag').forEach(tag => {
                const groupName = tag.dataset.group;
                if (topLevelGrouping[topLevelGroup].includes(groupName)) {
                    tag.classList.add('active');
                } else {
                    tag.classList.remove('active');
                }
            });
        }

        // Highlight connections for a group of usecases
        function highlightGroupConnections(usecaseList) {
            // Reset previous highlighting
            resetHighlighting();

            // Highlight all cells connected to these usecases
            usecaseList.forEach(usecase => {
                if (cellMap['usecase'][usecase]) {
                    cellMap['usecase'][usecase].classList.add('highlighted');

                    // Find and highlight connected cells
                    connections.forEach(conn => {
                        if (conn.usecase === usecase) {
                            cellMap['tech'][conn.tech].classList.add('highlighted');
                            cellMap['dataset'][conn.dataset].classList.add('highlighted');
                        }
                    });
                }
            });

            // Redraw connections with highlighting
            drawConnections(null, null, usecaseList);
        }

        // Calculate the height needed for the entire visualization
        function calculateTotalHeight() {
            // Get all cells and compute total height
            let maxHeight = 0;
            document.querySelectorAll('.column').forEach(column => {
                maxHeight = Math.max(maxHeight, column.scrollHeight);
            });

            // Set container height to accommodate all elements
            document.querySelector('.container').style.height = (maxHeight + 20) + 'px';

            // Resize canvas
            resizeCanvas();
        }

        // Initialize the visualization
        function init() {
            createGroupingUI();
            populateColumnsWithSubgroups();
            setupEventListeners();
            calculateTotalHeight();
            drawConnections();

            // Initialize canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }

        function resizeCanvas() {
            const canvas = document.getElementById('canvas');
            const container = document.querySelector('.container');
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;
            drawConnections();
        }

        // Populate columns with subgroups
        function populateColumnsWithSubgroups() {
            // Get all unique values first
            const techSet = new Set(data.map(row => row[0]));
            const usecaseSet = new Set(data.map(row => row[1]));
            const datasetSet = new Set(data.map(row => row[2]));

            // Create subgroups in tech column
            const techColumn = document.getElementById('tech-column');
            createSubgroups(techColumn, techSet, subgroups.tech, 'tech');

            // Create subgroups in usecase column
            const usecaseColumn = document.getElementById('usecase-column');
            createSubgroups(usecaseColumn, usecaseSet, subgroups.usecase, 'usecase');

            // Create subgroups in dataset column
            const datasetColumn = document.getElementById('dataset-column');
            createSubgroups(datasetColumn, datasetSet, subgroups.dataset, 'dataset');

            // Create connections based on data
            data.forEach(row => {
                connections.push({
                    tech: row[0],
                    usecase: row[1],
                    dataset: row[2]
                });
            });
        }

        // Create subgroups in a column
        function createSubgroups(column, allItems, subgroupDef, type) {
            // Create a set of all items for quick lookup
            const itemSet = new Set(allItems);

            // Track items that have been added to subgroups
            const addedItems = new Set();

            // First, create all defined subgroups
            for (const [groupName, groupInfo] of Object.entries(subgroupDef)) {
                const subgroupDiv = document.createElement('div');
                subgroupDiv.className = `subgroup ${groupInfo.class}`;

                const titleDiv = document.createElement('div');
                titleDiv.className = 'subgroup-title';
                titleDiv.textContent = groupName;
                subgroupDiv.appendChild(titleDiv);

                // Add cells for this subgroup
                groupInfo.items.forEach(item => {
                    if (itemSet.has(item)) {
                        addCell(subgroupDiv, item, type);
                        addedItems.add(item);
                    }
                });

                // Only add the subgroup if it has items
                if (subgroupDiv.querySelectorAll('.cell').length > 0) {
                    column.appendChild(subgroupDiv);
                }
            }

            // Add any items that weren't in defined subgroups
            if (addedItems.size < itemSet.size) {
                const otherDiv = document.createElement('div');
                otherDiv.className = 'subgroup';

                // Only add title if there are actually ungrouped items
                const remainingItems = Array.from(itemSet).filter(item => !addedItems.has(item));
                if (remainingItems.length > 0) {
                    const titleDiv = document.createElement('div');
                    titleDiv.className = 'subgroup-title';
                    titleDiv.textContent = 'Other';
                    otherDiv.appendChild(titleDiv);

                    remainingItems.forEach(item => {
                        addCell(otherDiv, item, type);
                    });

                    column.appendChild(otherDiv);
                }
            }
        }

        // Add a cell to a column or subgroup
        function addCell(parent, text, type) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.textContent = text.length > 25 ? text.substring(0, 25) + '...' : text;
            cell.dataset.value = text;
            cell.dataset.type = type;
            cell.title = text; // Add title for hover tooltip
            parent.appendChild(cell);

            // Store reference to cell
            if (!cellMap[type][text]) {
                cellMap[type][text] = cell;
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            // Cell click event
            document.querySelectorAll('.cell').forEach(cell => {
                cell.addEventListener('click', e => {
                    const clickedCell = e.target;
                    const value = clickedCell.dataset.value;
                    const type = clickedCell.dataset.type;

                    // Clear grouping selections when clicking on cells
                    document.querySelectorAll('.grouping-tag').forEach(tag => {
                        tag.classList.remove('active');
                    });

                    highlightConnections(value, type);
                    e.stopPropagation();
                });
            });

            // Reset highlighting when clicking elsewhere
            document.addEventListener('click', function (e) {
                // Don't reset if clicking on a grouping tag
                if (!e.target.classList.contains('grouping-tag')) {
                    resetHighlighting();

                    // Clear group selections
                    document.querySelectorAll('.grouping-tag').forEach(tag => {
                        tag.classList.remove('active');
                    });
                }
            });
        }

        // Highlight connected cells
        function highlightConnections(value, type) {
            // Reset previous highlighting
            resetHighlighting();

            // Highlight the clicked cell
            cellMap[type][value].classList.add('highlighted');

            // Find and highlight connected cells
            connections.forEach(conn => {
                if (type === 'tech' && conn.tech === value) {
                    cellMap['usecase'][conn.usecase].classList.add('highlighted');
                    cellMap['dataset'][conn.dataset].classList.add('highlighted');
                } else if (type === 'usecase' && conn.usecase === value) {
                    cellMap['tech'][conn.tech].classList.add('highlighted');
                    cellMap['dataset'][conn.dataset].classList.add('highlighted');
                } else if (type === 'dataset' && conn.dataset === value) {
                    cellMap['tech'][conn.tech].classList.add('highlighted');
                    cellMap['usecase'][conn.usecase].classList.add('highlighted');
                }
            });

            // Redraw connections with highlighting
            drawConnections(value, type);
        }

        // Reset highlighting
        function resetHighlighting() {
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('highlighted');
            });

            drawConnections();
        }

        // Calculate the position relative to the document
        function getAbsolutePosition(element) {
            const rect = element.getBoundingClientRect();
            return {
                top: rect.top + window.scrollY,
                bottom: rect.bottom + window.scrollY,
                left: rect.left + window.scrollX,
                right: rect.right + window.scrollX,
                width: rect.width,
                height: rect.height
            };
        }

        // Draw connections between cells
        function drawConnections(highlightValue, highlightType, highlightUsecaseList) {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const containerRect = canvas.getBoundingClientRect();
            const scrollY = window.scrollY;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            connections.forEach((conn, index) => {
                const techCell = cellMap['tech'][conn.tech];
                const usecaseCell = cellMap['usecase'][conn.usecase];
                const datasetCell = cellMap['dataset'][conn.dataset];

                if (techCell && usecaseCell && datasetCell) {
                    const isHighlighted =
                        (highlightType === 'tech' && conn.tech === highlightValue) ||
                        (highlightType === 'usecase' && conn.usecase === highlightValue) ||
                        (highlightType === 'dataset' && conn.dataset === highlightValue) ||
                        (highlightUsecaseList && highlightUsecaseList.includes(conn.usecase));

                    // Get color for this connection
                    const colorIndex = index % colors.length;
                    const color = colors[colorIndex];

                    // Get positions for each cell
                    const techRect = getAbsolutePosition(techCell);
                    const usecaseRect = getAbsolutePosition(usecaseCell);
                    const datasetRect = getAbsolutePosition(datasetCell);

                    // Adjust for scroll position
                    const techTop = techRect.top - containerRect.top - scrollY + window.scrollY;
                    const usecaseTop = usecaseRect.top - containerRect.top - scrollY + window.scrollY;
                    const datasetTop = datasetRect.top - containerRect.top - scrollY + window.scrollY;

                    // Draw tech to usecase connection
                    drawCurvedLine(
                        techRect.right - containerRect.left,
                        techTop + techRect.height / 2,
                        usecaseRect.left - containerRect.left,
                        usecaseTop + usecaseRect.height / 2,
                        canvas,
                        isHighlighted ? color : color + '40', // Add transparency if not highlighted
                        isHighlighted ? 2 : 1,
                        isHighlighted
                    );

                    // Draw usecase to dataset connection
                    drawCurvedLine(
                        usecaseRect.right - containerRect.left,
                        usecaseTop + usecaseRect.height / 2,
                        datasetRect.left - containerRect.left,
                        datasetTop + datasetRect.height / 2,
                        canvas,
                        isHighlighted ? color : color + '40', // Add transparency if not highlighted
                        isHighlighted ? 2 : 1,
                        isHighlighted
                    );
                }
            });
        }

        // Draw a curved line between two points
        function drawCurvedLine(startX, startY, endX, endY, canvas, color, lineWidth, isHighlighted) {
            const ctx = canvas.getContext('2d');

            // Calculate control point
            const controlX = (startX + endX) / 2;

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.bezierCurveTo(controlX, startY, controlX, endY, endX, endY);

            // Line style
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;

            // Add glow effect for highlighted connections
            if (isHighlighted) {
                ctx.shadowColor = color;
                ctx.shadowBlur = 5;
            } else {
                ctx.shadowBlur = 0;
            }

            ctx.stroke();

            // Reset shadow
            ctx.shadowBlur = 0;
        }

        // Update the visualization when scrolling
        window.addEventListener('scroll', function () {
            drawConnections();
        });

        // Initialize visualization when page loads
        window.onload = init;
    </script>
</body>

</html>